---
title: "packedMatrix"
date: "`r Sys.Date()`"
output: github_document
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
```

Based on discussion on R-devel beginning
[here](https://stat.ethz.ch/pipermail/r-devel/2021-November/081261.html)
and continued privately with Martin MÃ¤chler.

## Utilities

A basic helper for constructing `"packedMatrix"`, 
a virtual superclass of `"[dln][st]pMatrix"`:

```{r utils1, echo = TRUE} 
## Construct an 'n'-by-'n' "dspMatrix" storing a sequence of integers
newDsp <- function(n) {
  x <- as.double(seq_len(choose(n + 1L, 2L)))
  new("dspMatrix", uplo = "U", x = x, Dim = c(n, n),
      Dimnames = list(A = sprintf("i%d", seq_len(n)), B = NULL))
}
```

And two nonstandard evaluation tricks to avoid code duplication in
tests:

```{r utils2, echo=TRUE}
## For each call FUN(<packedMatrix>, ...) passed as argument,
## test equivalence to FUN(as(<packedMatrix>, "matrix"), ...)
checkEquiv <- function(...) {
  e <- parent.frame()
  equiv1 <- function(x1) {
    stopifnot(is.call(x1) && length(x1) > 1L)
    x2 <- x1
    x2[[2L]] <- call("as", x2[[2L]], "matrix") 
    m1 <- eval(x1, e)
    m2 <- eval(x2, e)
    if (is(m1, "Matrix")) {
      m1 <- as(m1, "matrix")
    }
    identical(m1, m2)
  }
  l <- as.list(match.call())[-1L]
  res <- vapply(l, equiv1, NA)
  names(res) <- vapply(l, deparse1, "")
  res
}

## Benchmark the calls FUN(<packedMatrix>, ...) passed as arguments,
## together with the calls FUN(as(<packedMatrix>, "matrix"), ...)
checkTimes <- function(..., times = 100L) {
  e <- parent.frame()
  f <- function(x) {
    stopifnot(is.call(x) && length(x) > 1L)
    x[[2L]] <- call("as", x[[2L]], "matrix")
    x
  }
  l1 <- as.list(match.call())[-1L]
  l1[["times"]] <- NULL
  l2 <- vector("list", 2L * length(l1))
  l2[c(TRUE, FALSE)] <- l1
  l2[c(FALSE, TRUE)] <- lapply(l1, f)
  cl <- as.call(c(list(quote(microbenchmark::microbenchmark)), l2, list(times = times)))
  eval(cl, e)
}
```

## Subset tests

For `"packedMatrix"`, the subset operator ```[``` avoids coercion to 
`"matrix"` in many special cases. Here is a list of subset operations
to be tested.

```{r subset1}
exprs <- alist(S[integer(0L)],
               S[c(0:6, NA)],
               S[-(0:6)],
               S[logical(0L)],
               S[TRUE],
               S[FALSE],
               S[NA],
               S[c(TRUE, FALSE, NA)],
               S[integer(0L), ],
               S[1L, ],
               S[1L, , drop = FALSE],
               S[c(0:1, NA), ],
               S[c(0:2, NA), ],
               S[-seq_len(nrow(S)), ],
               S[-seq_len(nrow(S))[-1L], ],
               S[-seq_len(nrow(S))[-(1:2)], ],
               S[logical(0L), ],
               S[TRUE, ],
               S[FALSE, ],
               S[NA, ],
               S[c(TRUE, FALSE, NA), ],
               S[character(0L), ],
               S[rownames(S)[1L], ],
               S[rownames(S)[1L], , drop = FALSE],
               S[rownames(S)[1:2], ],
               S[matrix(0L, 0L, 2L)],
               S[cbind(c(0:6, NA), c(NA, 6:0))],
               S[cbind(c(rownames(S), NA), c(NA, colnames(S)))],
               S[matrix(c(TRUE, FALSE), nrow(S), ncol(S))],
               S[NULL],
               S[NULL, ],
               S[, NULL])
```

We start by checking that the `"packedMatrix"` subset is consistent
with the subset via `"matrix"`.

```{r subset2}
library("Matrix")
S <- newDsp(10L)
all(do.call(checkEquiv, exprs))
```

Now we check that, in many cases, the `"packedMatrix"` subset is faster.

```{r subset3, echo=-1}
options(width = 500L)
S <- newDsp(1000L)
do.call(checkTimes, exprs)
```

The `"packedMatrix"` subset is slower in some cases because priority is 
given to memory efficiency:

```{r subset4, error=TRUE}
S <- newDsp(30000L)
i <- replace(logical(1000L), 1L, TRUE)
{S[i]; cat("done!\n")}
{as(S, "matrix")[i]; cat("done!\n")}
```

## Transpose tests

```{r transpose1}
S <- newDsp(1000L)
identical(as(t(S), "matrix"), t(as(S, "matrix")))
microbenchmark::microbenchmark(t(S), as(t(as(S, "dsyMatrix")), "dspMatrix"))
```
```{r transpose2, error=TRUE}
S <- newDsp(30000L)
{t(S); cat("done!\n")}
{as(t(as(S, "dsyMatrix")), "dspMatrix"); cat("done!\n")}
```
